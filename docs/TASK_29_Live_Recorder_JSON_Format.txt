"task": {
	// optional
	label="...",

	// mandatory
	"type": "Live-Recorder",

	// The Workflow ingested by the MMS Task Manager to add the generated Chunks
	// will have the following variables:
	// - currentUtcChunkStartTime, integer, UTC Start Time of the current chunk
	// - currentUtcChunkStartTime_HHMISS, string, Local Time having the HH:MI:SS format
	// - previousUtcChunkStartTime, integer, UTC Start Time of the previous chunk
	// - recordingCode, integer, delivery code of the Live Recorder
	// - ingestionJobLabel, string, ingestion job label of the Live Recorder
	"parameters": {

		// mandatory: it identifies the channel
		"configurationLabel": "",

		// mandatory
		//	It identifies this specific recording. In case for example
		//	- we have two recordings of the same channel
		//	- we need to use Live-Cut on the recorded channel
		//	In these scenarios, delivery code identifies each delivery.
		//	Internally the delivery code is used to
		//		- to label the generated chunks
		//		- as input in the Live-Cut task
		"recordingCode": 12345,

		// optional: user agent used only in case actAsServer is false
		"userAgent": "",

		// optional: It is possible to use this field to specify any other input options
		"otherInputOptions": "",

		// optional
		// - in case it is true, the Task will terminate in case of URL not found or forbidden error
		// - in case of false, the Task will terminate according the schedule and,
		//		in case of URL not found or forbidden error, it will sleep 30 seconds and retry
		// Default is false
		"exitInCaseOfUrlNotFoundOrForbidden": false,

		// mandatory: It specifies the recording period, his format is:
		//       - Zulu/UTC Date-time having the following format: YYYY-MM-DDTHH:MI:SSZ
		"schedule": {
			"start": "2019-01-21T12:30:00Z",
			"end": "2019-01-21T13:30:00Z",
			// If true, as soon as the End is reached, the recording will start again
			// with the following dates:
			//	Start will be set to the End
			//	End will be increased of the same period (End - Start)
			"autoRenew": false
		},

		// mandatory, it has to be as even number (numero pari) and cannot be smaller than 10
		//		MMS records the live feed and save it in files. This parameter specifies
		//		the duration in seconds of each media item (file) generated by MMS
		//		Example: 60 means a media item (file) each minute is generated.
		"segmentDuration": 60,

		// optional. It is the format of the media items (files) that will be generated by MMS.
		//		Default value is 'ts'.
		"outputFileFormat": "ts",

		// optional. To be set with the EncodersPool label only in case 
		// a specific encoders pool has to be used.
		// In case this field is initialized here, it overrides the one specified by the channel
		// configuration label
		"encodersPool": "",

		// optional. the LiveRecorderVOD is the Media Item updated continuously containing
		//	Live Recording. 
		// This field is optional, if not present no LiveRecorderVOD is generated.
		// By default LiveRecorderVirtualVOD is not present
		// VirtualVOD works also in case of an external transcoder
		"liveRecorderVirtualVOD": {

			// optional, VirtualVOD uses an HLS_Channel
			// It can be used a DEDICATED configuration label or
			// a SHARED free HLS channel
			"hlsChannelConfigurationLabel": "",

			// optional. it specifies the max duration of the LiveRecorderVOD in minutes
			//	Default is 120 minutes
			"maxDuration": 120,

			// This is an HLS profile and, generally, this is a low encoding profile
			//		The encoding profile can be specified using EncodingProfileKey or EncodingProfileLabel. 
			//      In case the EncodingProfileLabel is not unique in the system, ContentType has to be present too
			//      Possible values for the ContentType are: video, audio
			"encodingProfileKey": 1,
			"encodingProfileLabel": "MMS_HLS_H264_800Kb_veryfast_360p25_high422_AAC_92",
			"contentType": "video",
		}

		// monitorHLS allows to monitor the input stream providing an HLS delivery
		//	that can be used inside a player.
		// This field is optional, if not present no monitor HLS is generated. By default monitorHLS is not present
		// MonitorHLS works also in case of an external transcoder
		"monitorHLS": {

			// optional, Monitor uses an HLS_Channel
			// It can be used a DEDICATED configuration label or
			// a SHARED free HLS channel
			"hlsChannelConfigurationLabel": "",

			// optional: this parameter is needed in case we need a specific encoding profile for the monitor HLS.
			// This is an HLS profile and, generally, this is a low encoding profile
			//		The encoding profile can be specified using EncodingProfileKey or EncodingProfileLabel. 
			//      In case the EncodingProfileLabel is not unique in the system, ContentType has to be present too
			//      Possible values for the ContentType are: video, audio
			//	In case also LiveRecorderVirtualVOD is true, it is used the encoding profiles
			//	specified into the LiveRecorderVirtualVOD json section
			"encodingProfileKey": 1,
			"encodingProfileLabel": "MMS_HLS_H264_800Kb_veryfast_360p25_high422_AAC_92",
			"contentType": "video",
		},

		// optional: frames to be detected
		"framesToBeDetected": [
			{
				// picture to be detected into the video
				// At least when videoFrameToBeCropped is true, Width and Height
				// of the picture have to be even. May be this is also true
				// in case of videoFrameToBeCropped false.
				"picturePhysicalPathKey": 1234,
				// in case we have the comparition between the picture and
				// a portion of the video first it has to be done a crop
				// of the frame  of the video and then the comparition.
				// In this scenario, videoFrameToBeCropped will be true
				// and the crop of the video frame is done
				// using videoCrop_X, videoCrop_Y and the width/height
				// of the picture (picturePhysicalPathKey)
				"videoFrameToBeCropped": false,
				"videoCrop_X": 123,
				"videoCrop_Y": 678
			}
		],

		// Optional. This json array lists all the Outputs the Live-Recorder task has to generate.
		"outputs" = [
			{
				// optional, possible values: HLS_Channel, RTMP_Channel, CDN_AWS, CDN_CDN77.
				// HLS_Channel works also in case of an external transcoder
				// Default: HLS_Channel
				"outputType": "HLS_Channel",

				// optional, used only in case of HLS_Channel
				// the configuration label of an HLS Channel defined in MMS.
				// If not present, a SHARED free HLS channel is used
				"hlsChannelConfigurationLabel": "",

				// optional, used only in case of CDN_AWS
				// the configuration label of an AWS Channel defined in MMS.
				// If not present, a SHARED free AWS channel is used
				"awsChannelConfigurationLabel": "",

				// optional, used only in case of CDN_AWS
				// it specifies if a signed URL has to be used
				// Default: false
				"awsSignedURL": false,

				// optional, used only in case of CDN_AWS and awsSignedURL is true
				// it specifies the expiration of the signed URL
				// Default: 1440 (1 day)
				"awsExpirationInMinutes": 1440,

				// optional, used only in case of CDN_CDN77
				// the configuration label of an CDN77 Channel defined in MMS.
				// If not present, a SHARED free CDN77 channel is used
				"cdn77ChannelConfigurationLabel": "",

				// optional, used only in case of a signed CDN_CDN77 
				// it specifies the expiration of the signed URL
				// Default: 1440 (1 day)
				"cdn77ExpirationInMinutes": 1440,

				// optional, used only in case of RTMP_Channel
				// the configuration label of an RTMP Channel defined in MMS.
				// If not present, a SHARED free RTMP channel is used
				"rtmpChannelConfigurationLabel": "",

				// optional: It is possible to use this field to specify any other output options.
				// Examples:
				//	-map 0:1: specify to take the stream 1 from the first input (0) to be used in the output
				//	-map 0:a:2: specify to take the stream audio 2 from the first input (0) to be used in the output
				//	-map 0:v: specify to take all video from the first input (0) to be used in the output
				"otherOutputOptions": "-map 0:1",

				// optional
				"filters": {
					"video": [
						{
							"type": "fade",
							"duration": 4
						},
						{
							"type": "blackdetect",
							"black_min_duration": 2.0,
							"pixel_black_th": 0.0
						},
						{
							"type": "blackframe",
							"amount": 98,
							"threshold": 32
						},
						{
							"type": "freezedetect",
							"noiseInDb": -60,
							"duration": 2
						}
					],
					"audio": [
						{
							"type": "silencedetect",
							"noise": 0.0001
						},
						{
							"type": "volume",
							//	- 0.5: If we want our volume to be half of the input volume
							//	- 1.5: 150% of current volume
							//	- 10dB: increase the volume by 10dB
							//	- -5dB: reduce the volume by 5dB
							"factor": 5.0
						}
					],
					"complex": [
						{
							"type": "blackframe",
							"amount": 98,
							"threshold": 32
						},
						{
							"type": "blend",
							"mode": "difference",
							"shortest": 1
						}
					]
				},

				// optional: this parameter is needed only in case the streaming has to be encoded before proxying
				//    The encoding profile can be specified using EncodingProfileKey or EncodingProfileLabel.
				//		In case the EncodingProfileLabel is not unique in the system, ContentType has to be present too
				//		Possible values for the ContentType are: video, audio
				"encodingProfileKey": 1,
				"encodingProfileLabel": "Profile sport",
				"contentType": "video"
			}
		],

		// The system, during the live recording, performs several checks to be sure streaming is OK and,
		//	in case of issue, it might restart the recording.
		// This check can be disabled setting this flag to false.
		// Default is true
		"monitoringEnabled": true,
		// The system, during the live recording, checks if the frames number is always increasing and,
		//	in case of issue, it might restart the recording.
		// This check can be disabled setting this flag to false.
		// Default is true
		"monitoringFrameIncreasingEnabled": true,

		// optional: If present, it specifies when the Task has to be executed. The processing of the task
		//		can be delayed respect to the specified date based on his dependencies with other tasks.
		//		The date format is:
		//       - Zulu/UTC Date-time having the following format: YYYY-MM-DDTHH:MI:SSZ
		//	If it is not present, by default it will be initialized with the ingesion time
		"processingStartingFrom": "2019-01-21T12:30:00Z",

		// optional: It is used in case this Task has to wait a Task of another Workflow
		"waitFor": [
			{
				"globalIngestionLabel": "XXXX"
			}
		],

		// optional: it might contain any kind of user data (json format).
		// The platform stores them and returns this data to the Customer 
		// every time is requested.
		// The UserData are involved in searches as well
		"userData": { },

		// optional: it specifies the retention of the content (MediaItem/chunk retention). Once the retention expires,
		//		content including all his profiles (PhysicalItems) will be removed.
		//     Format: number + s (seconds) or m (minutes) or h (hours) or d (days) or M (month) or Y (year)
		//     Examples: 10s, 45m, 4h, 7d, 3M, 1y
		// By default it is 60m
		"retention": "60m",

		// optional: It is possible to specify a specific retention just for the profile (PhysicalItem).
		//		In this case, if the retention of the profile (PhysicalItem) expires before the retention of the
		//		content (MediaItem), only the profiles will be removed.
		//		It has not have sense specifies a PhysicalItem retention greater than the MediaItem retention.
		//		If it is not specified, only the MediaItem retention is used.
		"physicalItemRetention": "30m".

		// optional. Possible values: Low, Medium, High
		// If not present or if it is specifying a priority bigger than the allowed for this Workspace,
		//   the MaxEncodingPriority of the Workspace will be used.
		"encodingPriority": "Low",

		// optional
		"ingester": "my ingester",

		// optional. Tags to be assigned to the chunks generated by this task
		"tags": [ "tag 1", "tag 2" ],

		// optional: it specifies the filename without extension used by MMS when the content is delivered
		"deliveryFileName": "myFileName",

		// optional: by default the content is published.
		//    It specifies if and when the content is published.
		//    In case the content is not published, the delivery of the content will fail
		//    Possible values can be:
		//       - NOW
		//       - FOREVER
		//       - Zulu/UTC Date-time having the following format: YYYY-MM-DDTHH:MI:SSZ
		"publishing": {
			"startPublishing": "NOW",
			"endPublishing": "FOREVER"
		}
	}
}
